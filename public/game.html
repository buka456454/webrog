<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRog - Multiplayer Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            color: white;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        .game-container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px;
        }
        .sidebar {
            width: 280px;
            background: rgba(0, 0, 0, 0.8);
            border-left: 1px solid #333;
            display: flex;
            flex-direction: column;
            padding: 10px;
        }
        .controls {
            position: fixed;
            top: 32px;
            left: 32px;
            background: rgba(24,24,24,0.97);
            border: 1.5px solid #333;
            border-radius: 16px;
            padding: 22px 28px 18px 28px;
            z-index: 101;
            min-width: 340px;
            max-width: 420px;
            font-size: 16px;
            line-height: 1.7;
            box-shadow: 0 8px 32px #000a;
            color: #fff;
        }
        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 18px;
        }
        .controls-title {
            font-size: 22px;
            font-weight: 700;
            letter-spacing: 0.5px;
            color: #3fa7ff;
        }
        .controls-close {
            font-size: 22px;
            color: #aaa;
            cursor: pointer;
            user-select: none;
            transition: color 0.2s;
        }
        .controls-close:hover {
            color: #ff4444;
        }
        .controls-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .controls-list li {
            margin: 10px 0 0 0;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        canvas {
            border: 2px solid #333;
            border-radius: 8px;
            background: #0a0a0a;
            /* Размер управляется JavaScript */
            max-width: none !important;
            max-height: none !important;
            object-fit: none !important;
        }
        
        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px;
            justify-content: center;
            align-items: center;
            min-height: 0;
            position: relative;
        }
        
        #gameCanvas {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        .minimap {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            flex-shrink: 0;
        }
        .chat {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            background: #111827;
            border: 1px solid #4b5563;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            min-height: 150px;
        }
        .chat-input {
            display: flex;
            gap: 10px;
        }
        .chat-input input {
            flex: 1;
            padding: 8px;
            background: #1f2937;
            border: 1px solid #4b5563;
            border-radius: 4px;
            color: white;
        }
        .chat-input button {
            padding: 8px 16px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .chat-input button:hover {
            background: #1d4ed8;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        
        .modal-content h2 {
            margin: 0 0 15px 0;
            color: #0070f3;
            font-size: 24px;
        }
        
        .modal-content p {
            margin: 0 0 20px 0;
            color: #ccc;
            font-size: 16px;
        }
        
        .nickname-input {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .nickname-input input {
            flex: 1;
            padding: 12px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            color: white;
            font-size: 16px;
            outline: none;
        }
        
        .nickname-input input:focus {
            border-color: #0070f3;
        }
        
        .nickname-input button {
            padding: 12px 20px;
            background: #0070f3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }
        
        .nickname-input button:hover {
            background: #0056b3;
        }
        
        .nickname-error {
            color: #ff4444;
            font-size: 14px;
            min-height: 20px;
        }
        
        .respawn-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .respawn-content {
            background: #1a1a1a;
            border: 2px solid #ff4444;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        
        .respawn-content h2 {
            margin: 0 0 15px 0;
            color: #ff4444;
            font-size: 24px;
        }
        
        .respawn-content p {
            margin: 0 0 20px 0;
            color: #ccc;
            font-size: 16px;
        }
        
        .respawn-button {
            padding: 12px 24px;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background 0.2s;
        }
        
        .respawn-button:hover {
            background: #cc3333;
        }
        
        .leaderboard {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            flex-shrink: 0;
        }
        
        .leaderboard h3 {
            margin: 0 0 10px 0;
            color: #0070f3;
        }
        
        .leaderboard-list {
            max-height: 150px;
            overflow-y: auto;
        }
        
        .leaderboard-item {
            display: flex;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid #333;
            font-size: 14px;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            width: 25px;
            font-weight: bold;
            color: #0070f3;
        }
        
        .leaderboard-name {
            flex: 1;
            margin-left: 8px;
        }
        
        .leaderboard-kills {
            color: #ff4444;
            font-weight: bold;
        }
        
        .leaderboard-player-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        /* Адаптивность для маленьких экранов */
        @media (max-width: 1200px) {
            .sidebar {
                width: 240px;
            }
        }
        
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                height: 200px;
                flex-direction: row;
                overflow-x: auto;
            }
            .minimap, .leaderboard, .chat {
                min-width: 200px;
                margin-right: 10px;
            }
            .controls {
                max-width: 250px;
            }
            /* На мобильных устройствах размер canvas управляется JavaScript */
        }
        .rules-btn {
          position: fixed;
          top: 32px;
          left: 32px;
          z-index: 2000;
          background: #23272f;
          color: #3fa7ff;
          border: none;
          border-radius: 10px;
          padding: 12px 22px;
          font-size: 18px;
          font-weight: 600;
          cursor: pointer;
          box-shadow: 0 2px 8px #0005;
          transition: background 0.2s, color 0.2s;
        }
        .rules-btn:hover {
          background: #3fa7ff;
          color: #fff;
        }
        .rules-modal {
          position: fixed;
          top: 0; left: 0; width: 100vw; height: 100vh;
          z-index: 3000;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .rules-modal-backdrop {
          position: absolute;
          top: 0; left: 0; width: 100vw; height: 100vh;
          background: rgba(0,0,0,0.65);
          z-index: 1;
        }
        .rules-modal-content {
          position: relative;
          z-index: 2;
          background: #181a20;
          border-radius: 18px;
          box-shadow: 0 8px 32px #000a;
          min-width: 340px;
          max-width: 95vw;
          padding: 32px 36px 28px 36px;
          animation: rules-modal-in 0.22s cubic-bezier(.4,2,.6,1);
        }
        @keyframes rules-modal-in {
          from { opacity: 0; transform: scale(0.95); }
          to   { opacity: 1; transform: scale(1); }
        }
        .rules-modal-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 18px;
        }
        .rules-modal-title {
          font-size: 22px;
          font-weight: 700;
          color: #3fa7ff;
        }
        .rules-modal-close {
          font-size: 26px;
          color: #aaa;
          cursor: pointer;
          user-select: none;
          transition: color 0.2s;
        }
        .rules-modal-close:hover {
          color: #ff4444;
        }
        .rules-list {
          list-style: none;
          padding: 0;
          margin: 0;
        }
        .rules-list li {
          margin: 12px 0 0 0;
          font-size: 17px;
          display: flex;
          align-items: center;
          gap: 10px;
          color: #e0e0e0;
        }
    </style>
</head>
<body>
    <div id="nicknameModal" class="modal">
        <div class="modal-content">
            <h2>🎮 Welcome to WebRog!</h2>
            <p>Enter your nickname to join the game:</p>
            <div class="nickname-input">
                <input type="text" id="nicknameInput" placeholder="Enter your nickname..." maxlength="20" autocomplete="off">
                <button onclick="joinGame()">Join Game</button>
            </div>
            <div class="nickname-error" id="nicknameError"></div>
        </div>
    </div>

    <div id="respawnModal" class="respawn-modal">
        <div class="respawn-content">
            <h2>💀 Вы погибли!</h2>
            <p>Нажмите кнопку ниже, чтобы возродиться</p>
            <button class="respawn-button" onclick="respawnPlayer()">Возродиться</button>
        </div>
    </div>

    <div class="game-container" id="gameContainer" style="display: none;">
        <!-- Кнопка для открытия модалки с правилами -->
        <button class="rules-btn" id="rulesBtn" onclick="openRulesModal()">📖 Правила</button>
        <!-- Модалка с правилами -->
        <div class="rules-modal" id="rulesModal" style="display:none;">
          <div class="rules-modal-backdrop" onclick="closeRulesModal(event)"></div>
          <div class="rules-modal-content">
            <div class="rules-modal-header">
              <span class="rules-modal-title">📖 Правила игры</span>
              <span class="rules-modal-close" onclick="closeRulesModal(event)">✕</span>
            </div>
            <ul class="rules-list">
              <li>⌨️ Используй WASD для движения</li>
              <li>⚡ SHIFT — рывок к курсору</li>
              <li>⚔️ E — подобрать оружие</li>
              <li>🗑️ Q — выбросить оружие</li>
              <li>🗡️ ЛКМ — атака</li>
              <li>💬 Чат для общения</li>
              <li>👥 <span id="playerCount">0</span> игроков онлайн</li>
            </ul>
          </div>
        </div>
        <div class="game-area" style="width:100%;height:100%;display:flex;justify-content:center;align-items:center;">
            <canvas id="gameCanvas"></canvas>
        </div>
        
        <div class="sidebar">
            <div class="minimap">
                <h3>🗺️ Mini Map</h3>
                <canvas id="minimapCanvas" width="200" height="150"></canvas>
            </div>
            
            <div class="leaderboard">
                <h3>🏆 Топ по киллам</h3>
                <div id="leaderboardList" class="leaderboard-list">
                    <div style="color: #6b7280; font-size: 14px;">Загрузка топа...</div>
                </div>
            </div>
            
            <div class="chat">
                <h3>💬 Chat</h3>
                <div id="chatMessages" class="chat-messages">
                    <div style="color: #6b7280; font-size: 14px;">Connecting to server...</div>
                </div>
                <div class="chat-input">
                    <input type="text" id="chatInput" placeholder="Type a message..." maxlength="200">
                    <button onclick="sendMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Синхронизация размеров canvas с DOM
        function resizeGameCanvas() {
            const container = document.querySelector('.game-area');
            if (!container) return;
            
            // Определяем размер canvas в зависимости от размера экрана
            let canvasWidth, canvasHeight;
            
            if (window.innerWidth <= 768) {
                // Мобильные устройства
                canvasWidth = 800;
                canvasHeight = 600;
            } else {
                // Десктоп
                canvasWidth = 1200;
                canvasHeight = 800;
            }
            
            // Устанавливаем размер canvas
            gameCanvas.width = canvasWidth;
            gameCanvas.height = canvasHeight;
            
            // Устанавливаем CSS размер для отображения
            gameCanvas.style.width = canvasWidth + 'px';
            gameCanvas.style.height = canvasHeight + 'px';
        }
        window.addEventListener('resize', resizeGameCanvas);
        document.addEventListener('DOMContentLoaded', resizeGameCanvas);
        
        // Также вызываем resizeGameCanvas при загрузке страницы
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', resizeGameCanvas);
        } else {
            resizeGameCanvas();
        }
        
        // Глобальные функции для возрождения
        function respawnPlayer() {
            console.log('Кнопка возрождения нажата');
            if (socket) {
                console.log('Отправляем событие playerRespawn');
                socket.emit('playerRespawn');
                hideRespawnModal();
            } else {
                console.log('Socket не найден!');
            }
        }
        
        function showRespawnModal() {
            console.log('Показываем модалку возрождения');
            if (respawnModal) {
                respawnModal.style.display = 'flex';
                console.log('Модалка отображена:', respawnModal.style.display);
            } else {
                console.log('Модалка не найдена!');
            }
        }
        
        function hideRespawnModal() {
            console.log('Скрываем модалку возрождения');
            if (respawnModal) {
                respawnModal.style.display = 'none';
            }
        }
        
        let socket = null;
        const gameCanvas = document.getElementById('gameCanvas');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const playerCount = document.getElementById('playerCount');
        const nicknameModal = document.getElementById('nicknameModal');
        const gameContainer = document.getElementById('gameContainer');
        const nicknameInput = document.getElementById('nicknameInput');
        const nicknameError = document.getElementById('nicknameError');
        const respawnModal = document.getElementById('respawnModal');
        console.log('Модалка возрождения найдена:', !!respawnModal);
        
        let players = [];
        let currentPlayerId = '';
        let gameCtx = gameCanvas.getContext('2d');
        let minimapCtx = minimapCanvas.getContext('2d');
        let obstacles = [];
        let weapons = [];
        let mapWidth = 2000;
        let mapHeight = 1500;
        
        let keys = {};
        let moveSpeed = 2; // Базовая скорость, будет обновляться сервером
        let moveInterval;
        let mouseX = 0;
        let mouseY = 0;
        let attackCooldown = false;
        const attackCooldownTime = 500;
        
        // Система рывков
        let dashCooldown = false;
        let dashCooldownTime = 2000; // 2 секунды КД
        let dashDistance = 80; // дистанция рывка (уменьшена)
        let dashSpeed = 7; // скорость рывка (ещё меньше)
        let dashStartTime = 0;
        let isDashing = false;
        let dashTargetX = 0;
        let dashTargetY = 0;
        
        // Анимация удара
        let attackAnimation = {
            isActive: false,
            startTime: 0,
            duration: 300,
            angle: 0,
            swingDirection: 1
        };
        
        // Анимации ударов для всех игроков
        let playerAttackAnimations = new Map();
        
        // Частицы для эффектов
        let particles = [];
        
        // --- Глобальные переменные для плавной камеры ---
        let camX = 0, camY = 0;
        let camTargetX = 0, camTargetY = 0;
        const camSmooth = 0.12; // Чем меньше, тем плавнее
        // ---
        
        // --- ДОБАВЛЯЕМ КД ДЛЯ ОРУЖИЯ ---
        // При спавне оружия (и при подборе) добавляем поле cooldown
        function getWeaponCooldown(type) {
            if (type === 'knife') return 400;
            if (type === 'greatsword') return 900;
            return 600; // обычный меч
        }
        // ---
        
        let nextAttackTime = 0; // локально для текущего игрока
        
        // --- НАСТРОЙКИ ИГРЫ ---
        let gameSettings = {
            damage: 3,
            range: 80,
            knifeDamage: 2,
            knifeRange: 60,
            greatswordDamage: 5,
            greatswordRange: 110
        };

        function applySettingsToWeapon(weapon) {
            if (!weapon) return;
            if (weapon.type === 'knife') {
                weapon.damage = gameSettings.knifeDamage;
                weapon.range = gameSettings.knifeRange;
            } else if (weapon.type === 'greatsword') {
                weapon.damage = gameSettings.greatswordDamage;
                weapon.range = gameSettings.greatswordRange;
            } else {
                weapon.damage = gameSettings.damage;
                weapon.range = gameSettings.range;
            }
        }

        function applySettingsToAllWeapons() {
            // На карте
            weapons.forEach(applySettingsToWeapon);
            // У игроков
            players.forEach(p => applySettingsToWeapon(p.weapon));
            // У текущего игрока (если вдруг не обновился)
            const me = players.find(p => p.id === currentPlayerId);
            if (me && me.weapon) applySettingsToWeapon(me.weapon);
            // Мгновенно обновить интерфейс
            if (typeof updateGame === 'function') updateGame();
        }

        // --- МОДАЛКА НАСТРОЕК ---
        const settingsModal = document.createElement('div');
        settingsModal.style.display = 'none';
        settingsModal.style.position = 'fixed';
        settingsModal.style.top = '0';
        settingsModal.style.left = '0';
        settingsModal.style.width = '100vw';
        settingsModal.style.height = '100vh';
        settingsModal.style.background = 'rgba(0,0,0,0.85)';
        settingsModal.style.zIndex = '2000';
        settingsModal.style.justifyContent = 'center';
        settingsModal.style.alignItems = 'center';
        settingsModal.style.transition = 'opacity 0.25s cubic-bezier(.4,2,.6,1), transform 0.25s cubic-bezier(.4,2,.6,1)';
        settingsModal.style.opacity = '0';
        settingsModal.innerHTML = `
          <div id="settings-content" style="background:#222;padding:32px 24px 24px 24px;border-radius:16px;min-width:320px;max-width:90vw;box-shadow:0 8px 32px #000a;display:flex;flex-direction:column;gap:18px;align-items:center;position:relative;transform:scale(0.95);transition:opacity 0.25s, transform 0.25s;">
            <div id="settings-close-x" style="position:absolute;top:10px;right:14px;font-size:22px;color:#00bfff;cursor:pointer;user-select:none;">✕</div>
            <h2 style="color:#00bfff;margin:0 0 10px 0;">Настройки игры</h2>
            <div style="width:100%;height:1px;background:#333;margin:4px 0 10px 0;"></div>
            <label style="color:#fff;">Урон меча: <input id="set-damage" type="number" min="1" max="99" value="3" style="width:60px;padding:3px 6px;border-radius:5px;border:1px solid #444;outline:none;transition:box-shadow 0.2s;"></label>
            <label style="color:#fff;">Радиус меча: <input id="set-range" type="number" min="10" max="200" value="80" style="width:60px;padding:3px 6px;border-radius:5px;border:1px solid #444;outline:none;transition:box-shadow 0.2s;"></label>
            <div style="width:100%;height:1px;background:#333;margin:8px 0 2px 0;"></div>
            <label style="color:#fff;">Урон ножа: <input id="set-knife-damage" type="number" min="1" max="99" value="2" style="width:60px;padding:3px 6px;border-radius:5px;border:1px solid #444;outline:none;transition:box-shadow 0.2s;"></label>
            <label style="color:#fff;">Радиус ножа: <input id="set-knife-range" type="number" min="10" max="200" value="60" style="width:60px;padding:3px 6px;border-radius:5px;border:1px solid #444;outline:none;transition:box-shadow 0.2s;"></label>
            <div style="width:100%;height:1px;background:#333;margin:8px 0 2px 0;"></div>
            <label style="color:#fff;">Урон двуручного: <input id="set-greatsword-damage" type="number" min="1" max="99" value="5" style="width:60px;padding:3px 6px;border-radius:5px;border:1px solid #444;outline:none;transition:box-shadow 0.2s;"></label>
            <label style="color:#fff;">Радиус двуручного: <input id="set-greatsword-range" type="number" min="10" max="200" value="110" style="width:60px;padding:3px 6px;border-radius:5px;border:1px solid #444;outline:none;transition:box-shadow 0.2s;"></label>
            <button id="close-settings" style="margin-top:18px;padding:8px 24px;background:#00bfff;color:#fff;border:none;border-radius:6px;font-size:16px;cursor:pointer;box-shadow:0 2px 8px #0005;">Закрыть</button>
          </div>
        `;
        document.body.appendChild(settingsModal);

        // Анимация появления/скрытия
        function openSettingsModal() {
            document.getElementById('set-damage').value = gameSettings.damage;
            document.getElementById('set-range').value = gameSettings.range;
            document.getElementById('set-knife-damage').value = gameSettings.knifeDamage;
            document.getElementById('set-knife-range').value = gameSettings.knifeRange;
            document.getElementById('set-greatsword-damage').value = gameSettings.greatswordDamage;
            document.getElementById('set-greatsword-range').value = gameSettings.greatswordRange;
            settingsModal.style.display = 'flex';
            setTimeout(()=>{
                settingsModal.style.opacity = '1';
                document.getElementById('settings-content').style.opacity = '1';
                document.getElementById('settings-content').style.transform = 'scale(1)';
            }, 10);
        }
        function closeSettingsModal() {
            settingsModal.style.opacity = '0';
            document.getElementById('settings-content').style.opacity = '0.7';
            document.getElementById('settings-content').style.transform = 'scale(0.95)';
            setTimeout(()=>{settingsModal.style.display = 'none';}, 220);
        }
        document.getElementById('close-settings').onclick = closeSettingsModal;
        document.getElementById('settings-close-x').onclick = closeSettingsModal;

        // Подсветка инпутов при фокусе
        ['set-damage','set-range','set-knife-damage','set-knife-range','set-greatsword-damage','set-greatsword-range'].forEach(id => {
            const el = document.getElementById(id);
            el.onfocus = () => { el.style.boxShadow = '0 0 0 2px #00bfff'; };
            el.onblur = () => { el.style.boxShadow = 'none'; };
            el.style.cursor = 'pointer';
            el.oninput = function() {
                gameSettings.damage = +document.getElementById('set-damage').value;
                gameSettings.range = +document.getElementById('set-range').value;
                gameSettings.knifeDamage = +document.getElementById('set-knife-damage').value;
                gameSettings.knifeRange = +document.getElementById('set-knife-range').value;
                gameSettings.greatswordDamage = +document.getElementById('set-greatsword-damage').value;
                gameSettings.greatswordRange = +document.getElementById('set-greatsword-range').value;
                applySettingsToAllWeapons();
            };
        });
        // ---

        // --- ОТКРЫТИЕ НАСТРОЕК ПО СЛОВУ ---
        chatInput.addEventListener('keypress', (e) => {
            if (e.code === 'Enter') {
                if (chatInput.value.trim().toLowerCase() === 'писюн') {
                    openSettingsModal();
                    chatInput.value = '';
                    e.preventDefault();
                    return;
                }
                sendMessage();
            }
        });
        // ... существующий код ...

        // При спавне/подборе оружия сразу применяем настройки:
        socket.on('gameState', (data) => {
            // ... существующий код ...
            weapons.forEach(w => { w.cooldown = getWeaponCooldown(w.type); applySettingsToWeapon(w); });
            // ... существующий код ...
            players = data.players || [];
            if (data.yourId !== null && data.yourId !== undefined) {
                currentPlayerId = data.yourId;
            }
        });
        socket.on('weaponSpawned', (weapon) => {
            applySettingsToWeapon(weapon);
            weapons.push(weapon);
        });
        socket.on('weaponPickedUp', (data) => {
            // ... существующий код ...
            if (data.player && data.player.weapon) {
                data.player.weapon.cooldown = getWeaponCooldown(data.player.weapon.type);
                applySettingsToWeapon(data.player.weapon);
            }
            // ... существующий код ...
        });
        // ... существующий код ...

        function joinGame() {
            const nickname = nicknameInput.value.trim();
            if (!nickname || nickname.length < 2) {
                nicknameError.textContent = 'Nickname must be at least 2 characters long';
                return;
            }
            
            socket = io();
            
            socket.on('connect', () => {
                socket.emit('setNickname', nickname);
            });
            
            socket.on('gameState', (data) => {
                players = data.players || [];
                if (data.yourId !== null && data.yourId !== undefined) {
                    currentPlayerId = data.yourId;
                }
                obstacles = data.obstacles || [];
                weapons = data.weapons || [];
                mapWidth = data.mapWidth || 2000;
                mapHeight = data.mapHeight || 1500;
                
                nicknameModal.style.display = 'none';
                gameContainer.style.display = 'flex';
                
                startGame();
                
                // Проставляем кд для оружия на карте
                weapons.forEach(w => { w.cooldown = getWeaponCooldown(w.type); applySettingsToWeapon(w); });
                
                // Устанавливаем начальную скорость для текущего игрока
                const me = players.find(p => p.id === currentPlayerId);
                if (me && typeof me.speed === 'number') {
                    moveSpeed = me.speed;
                }
            });
            
            socket.on('nicknameError', (error) => {
                nicknameError.textContent = error;
            });
            
            socket.on('playerJoined', (player) => {
                players.push(player);
                addChatMessage('System', `${player.name} joined the game`);
            });
            
            socket.on('playerLeft', (playerId) => {
                players = players.filter(p => p.id !== playerId);
                addChatMessage('System', 'A player left the game');
            });
            
            socket.on('playerMoved', (data) => {
                const player = players.find(p => p.id === data.id);
                if (player) {
                    // Проверяем, не застрял ли игрок во время рывка
                    if (data.id === currentPlayerId && isDashing) {
                        const dx = data.x - player.x;
                        const dy = data.y - player.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Если игрок не сдвинулся или сдвинулся очень мало, значит рывок заблокирован
                        if (distance < 2) {
                            isDashing = false; // Прерываем рывок
                        }
                    }
                    
                    player.x = data.x;
                    player.y = data.y;
                }
            });
            
            socket.on('playerRotated', (data) => {
                const player = players.find(p => p.id === data.id);
                if (player) {
                    player.rotation = data.rotation;
                }
            });
            
            socket.on('chatMessage', (message) => {
                addChatMessage(message.playerName, message.message);
            });
            
            socket.on('weaponAttack', (data) => {
                // Создаем частицы для атаки других игроков
                const attacker = players.find(p => p.id === data.attackerId);
                if (attacker && attacker.id !== currentPlayerId) {
                    createAttackParticles(attacker.x, attacker.y, attacker.rotation || 0);
                    // Запускаем анимацию удара для атакующего игрока
                    playerAttackAnimations.set(data.attackerId, {
                        isActive: true,
                        startTime: Date.now(),
                        duration: 300,
                        swingDirection: Math.random() > 0.5 ? 1 : -1
                    });
                    // Просто обновляем здоровье:
                    data.attackedPlayers.forEach(attacked => {
                        const player = players.find(p => p.id === attacked.id);
                        if (player) {
                            player.health = attacked.newHealth;
                        }
                    });
                }
            });
            
                    socket.on('playerDied', (data) => {
            console.log('Получено событие playerDied:', data);
            addChatMessage('System', data.message);
            
            // Если умер текущий игрок, показываем модалку возрождения
            if (data.playerId === currentPlayerId) {
                console.log('Показываем модалку возрождения для текущего игрока');
                showRespawnModal();
            }
            
            // Обновляем состояние умершего игрока
            const playerIndex = players.findIndex(p => p.id === data.playerId);
            if (playerIndex !== -1) {
                players[playerIndex].isDead = true;
                players[playerIndex].health = 0;
                console.log('Игрок помечен как мертвый:', players[playerIndex]);
            }
        });
            
            socket.on('weaponSpawned', (weapon) => {
                applySettingsToWeapon(weapon);
                weapons.push(weapon);
            });
            
            socket.on('weaponPickedUp', (data) => {
                // Удаляем оружие из массива
                const weaponsBefore = weapons.length;
                weapons = weapons.filter(w => w.id !== data.weaponId);
                // Обновляем данные игрока с оружием
                const playerIndex = players.findIndex(p => p.id === data.playerId);
                if (playerIndex !== -1 && data.player) {
                    const oldPlayer = players[playerIndex];
                    players[playerIndex] = { ...oldPlayer, ...data.player };
                }
                if (data.player && data.player.weapon) {
                    data.player.weapon.cooldown = getWeaponCooldown(data.player.weapon.type);
                    applySettingsToWeapon(data.player.weapon);
                }
                // Обновляем скорость для текущего игрока
                if (data.playerId === currentPlayerId && data.player && typeof data.player.speed === 'number') {
                    moveSpeed = data.player.speed;
                }
            });
            
            socket.on('weaponDropped', (data) => {
                // Добавляем выброшенное оружие на карту
                if (data.weapon) {
                    applySettingsToWeapon(data.weapon);
                    weapons.push(data.weapon);
                }
                
                // Обновляем данные игрока без оружия
                const playerIndex = players.findIndex(p => p.id === data.playerId);
                if (playerIndex !== -1 && data.player) {
                    const oldPlayer = players[playerIndex];
                    players[playerIndex] = { ...oldPlayer, ...data.player };
                }
                
                // Обновляем скорость для текущего игрока
                if (data.playerId === currentPlayerId && data.player && typeof data.player.speed === 'number') {
                    moveSpeed = data.player.speed;
                }
            });
            
            socket.on('weaponBroken', (data) => {
                // Обновляем данные игрока когда оружие ломается
                const playerIndex = players.findIndex(p => p.id === data.playerId);
                if (playerIndex !== -1 && data.player) {
                    players[playerIndex] = { ...players[playerIndex], ...data.player };
                    delete players[playerIndex].weapon;
                }
                // Обновляем скорость для текущего игрока
                if (data.playerId === currentPlayerId && data.player && typeof data.player.speed === 'number') {
                    moveSpeed = data.player.speed;
                }
            });
            
            socket.on('playerUpdated', (data) => {
                players = players.map(p => p.id === data.playerId ? { ...data.player } : p);
                if (data.playerId === currentPlayerId) {
                    const me = players.find(p => p.id === currentPlayerId);
                    console.clear();
                    console.log('DURABILITY:', me && me.weapon ? me.weapon.durability : 'нет меча');
                    // Обновляем скорость движения для текущего игрока
                    if (me && typeof me.speed === 'number') {
                        moveSpeed = me.speed;
                    }
                }
            });
            
            socket.on('playerDashed', (data) => {
                // Создаем эффект рывка для других игроков
                const player = players.find(p => p.id === data.id);
                if (player && data.id !== currentPlayerId) {
                    createDashEffect(data.x, data.y);
                }
            });
            
            socket.on('playerRespawned', (data) => {
                console.log('Получено событие playerRespawned:', data);
                // Обновляем данные возродившегося игрока
                const playerIndex = players.findIndex(p => p.id === data.playerId);
                if (playerIndex !== -1 && data.player) {
                    players[playerIndex] = { ...players[playerIndex], ...data.player };
                    console.log('Игрок обновлен:', players[playerIndex]);
                }
                
                // Если это текущий игрок, скрываем модалку и обновляем скорость
                if (data.playerId === currentPlayerId) {
                    console.log('Скрываем модалку возрождения');
                    hideRespawnModal();
                    if (data.player && typeof data.player.speed === 'number') {
                        moveSpeed = data.player.speed;
                    }
                }
            });
            
            socket.on('leaderboardUpdate', (leaderboard) => {
                updateLeaderboard(leaderboard);
            });
        }
        
        function startGame() {
            // Инициализируем размер canvas
            resizeGameCanvas();
            
            // Keyboard events
            document.addEventListener('keydown', (e) => {
                keys[e.code.toLowerCase()] = true;
                
                // Рывок по Shift
                if ((e.code === 'ShiftLeft' || e.code === 'ShiftRight') && !dashCooldown && !isDashing) {
                    const currentPlayer = players.find(p => p.id === currentPlayerId);
                    if (currentPlayer && !currentPlayer.isDead) {
                        // Вычисляем направление рывка (к курсору мыши)
                        const dx = mouseX - (currentPlayer.x - camX);
                        const dy = mouseY - (currentPlayer.y - camY);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            // Нормализуем вектор и умножаем на дистанцию рывка
                            const normalizedDx = (dx / distance) * dashDistance;
                            const normalizedDy = (dy / distance) * dashDistance;
                            
                            dashTargetX = currentPlayer.x + normalizedDx;
                            dashTargetY = currentPlayer.y + normalizedDy;
                            
                            // Ограничиваем рывок границами карты
                            dashTargetX = Math.max(25, Math.min(dashTargetX, mapWidth - 25));
                            dashTargetY = Math.max(25, Math.min(dashTargetY, mapHeight - 25));
                            
                            isDashing = true;
                            dashCooldown = true;
                            dashStartTime = Date.now(); // Запускаем КД сразу
                            
                            // Создаем эффект рывка
                            createDashEffect(currentPlayer.x, currentPlayer.y);
                            
                            // Уведомляем сервер о рывке
                            socket.emit('playerDash', {
                                x: currentPlayer.x,
                                y: currentPlayer.y,
                                targetX: dashTargetX,
                                targetY: dashTargetY
                            });
                        }
                    }
                }
                
                // Weapon pickup
                if (e.code === 'KeyE') {
                    const currentPlayer = players.find(p => p.id === currentPlayerId);
                    if (currentPlayer && !currentPlayer.isDead) {
                        weapons.forEach(weapon => {
                            const distance = Math.sqrt(
                                Math.pow(currentPlayer.x - weapon.x, 2) + Math.pow(currentPlayer.y - weapon.y, 2)
                            );
                            if (distance < 50) { // Увеличил радиус подбора
                                socket.emit('pickupWeapon', weapon.id);
                            }
                        });
                    }
                }
                
                // Weapon drop
                if (e.code === 'KeyQ') {
                    const currentPlayer = players.find(p => p.id === currentPlayerId);
                    if (currentPlayer && currentPlayer.weapon && !currentPlayer.isDead) {
                        socket.emit('dropWeapon');
                    }
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.code.toLowerCase()] = false;
            });
            
            // Mouse events
            gameCanvas.addEventListener('mousemove', (e) => {
                const rect = gameCanvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
            });
            
            gameCanvas.addEventListener('click', () => {
                const currentPlayer = players.find(p => p.id === currentPlayerId);
                if (!currentPlayer || !currentPlayer.weapon || currentPlayer.isDead) return;
                const now = Date.now();
                const weaponCooldown = currentPlayer.weapon.cooldown || getWeaponCooldown(currentPlayer.weapon.type);
                if (now < nextAttackTime || attackCooldown) return; // кд не прошло или уже атакуем
                nextAttackTime = now + weaponCooldown;
                attackCooldown = true;
                
                // Запускаем анимацию удара
                attackAnimation.isActive = true;
                attackAnimation.startTime = Date.now();
                attackAnimation.angle = currentPlayer.rotation || 0;
                attackAnimation.swingDirection = Math.random() > 0.5 ? 1 : -1;
                
                // Создаем частицы удара только при начале анимации
                createAttackParticles(currentPlayer.x, currentPlayer.y, currentPlayer.rotation || 0);
                
                // Добавляем экранную тряску для эффекта
                gameCanvas.style.transform = 'translate(2px, 2px)';
                setTimeout(() => {
                    gameCanvas.style.transform = 'translate(0px, 0px)';
                }, 50);
                
                console.log('Отправляем weaponAttack, durability:', currentPlayer.weapon.durability);
                socket.emit('weaponAttack');
                setTimeout(() => {
                    attackCooldown = false;
                }, attackCooldownTime);
            });
            
            // Chat input
            chatInput.addEventListener('keypress', (e) => {
                if (e.code === 'Enter') {
                    sendMessage();
                }
            });
            
            // Start game loop
            moveInterval = setInterval(updateGame, 16);
            requestAnimationFrame(renderGame);
        }
        
        function updateGame() {
            const currentPlayer = players.find(p => p.id === currentPlayerId);
            if (!currentPlayer) return;
            
            // Если игрок мертв, не обрабатываем движение
            if (currentPlayer.isDead) return;
            
            let moved = false;
            let newX = currentPlayer.x;
            let newY = currentPlayer.y;
            
            // Обработка рывка
            if (isDashing) {
                const dx = dashTargetX - currentPlayer.x;
                const dy = dashTargetY - currentPlayer.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) {
                    // Продолжаем рывок
                    const normalizedDx = (dx / distance) * dashSpeed;
                    const normalizedDy = (dy / distance) * dashSpeed;
                    
                    newX = currentPlayer.x + normalizedDx;
                    newY = currentPlayer.y + normalizedDy;
                    moved = true;
                } else {
                    // Рывок завершен
                    isDashing = false;
                    newX = dashTargetX;
                    newY = dashTargetY;
                    moved = true;
                }
            } else {
                // Обычное движение
                if (keys['keyw'] || keys['arrowup']) {
                    newY -= moveSpeed;
                    moved = true;
                }
                if (keys['keys'] || keys['arrowdown']) {
                    newY += moveSpeed;
                    moved = true;
                }
                if (keys['keya'] || keys['arrowleft']) {
                    newX -= moveSpeed;
                    moved = true;
                }
                if (keys['keyd'] || keys['arrowright']) {
                    newX += moveSpeed;
                    moved = true;
                }
            }
            
            if (moved) {
                socket.emit('playerMove', { x: newX, y: newY });
            }
            
            // Update rotation (учитываем смещение камеры)
            const dx = mouseX - (currentPlayer.x - camX);
            const dy = mouseY - (currentPlayer.y - camY);
            const rotation = Math.atan2(dy, dx) + Math.PI / 2;
            socket.emit('playerRotate', { rotation });
            
            // Обновляем анимацию удара
            if (attackAnimation.isActive) {
                const elapsed = Date.now() - attackAnimation.startTime;
                if (elapsed >= attackAnimation.duration) {
                    attackAnimation.isActive = false;
                }
            }
            
            // Обновляем анимации ударов всех игроков
            playerAttackAnimations.forEach((animation, playerId) => {
                const elapsed = Date.now() - animation.startTime;
                if (elapsed >= animation.duration) {
                    playerAttackAnimations.delete(playerId);
                }
            });
            
            // Обновляем частицы
            updateParticles();
            
            // Обновляем время КД рывка
            if (dashCooldown) {
                const elapsed = Date.now() - dashStartTime;
                if (elapsed >= dashCooldownTime) {
                    dashCooldown = false;
                }
            }
            
            // Update player count
            playerCount.textContent = players.length;
        }
        
        function renderGame() {
            // Получаем реальные размеры canvas
            const canvasWidth = gameCanvas.width;
            const canvasHeight = gameCanvas.height;
            // Найти текущего игрока
            const currentPlayer = players.find(p => p.id === currentPlayerId);
            // Куда хотим камеру
            if (currentPlayer) {
                camTargetX = currentPlayer.x - canvasWidth / 2;
                camTargetY = currentPlayer.y - canvasHeight / 2;
                camTargetX = Math.max(0, Math.min(camTargetX, mapWidth - canvasWidth));
                camTargetY = Math.max(0, Math.min(camTargetY, mapHeight - canvasHeight));
            }
            // Плавное движение камеры
            camX += (camTargetX - camX) * camSmooth;
            camY += (camTargetY - camY) * camSmooth;
            // Очистить канвас
            gameCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            gameCtx.fillStyle = '#0a0a0a';
            gameCtx.fillRect(0, 0, canvasWidth, canvasHeight);
            // Сетка
            gameCtx.strokeStyle = '#222';
            gameCtx.lineWidth = 1;
            for (let x = 0; x <= canvasWidth; x += 40) {
                gameCtx.beginPath();
                gameCtx.moveTo(x, 0);
                gameCtx.lineTo(x, canvasHeight);
                gameCtx.stroke();
            }
            for (let y = 0; y <= canvasHeight; y += 40) {
                gameCtx.beginPath();
                gameCtx.moveTo(0, y);
                gameCtx.lineTo(canvasWidth, y);
                gameCtx.stroke();
            }
            // Радиусы удара (на заднем плане)
            players.forEach(player => {
                const isCurrentPlayer = player.id === currentPlayerId;
                if (isCurrentPlayer && player.weapon) {
                    const range = player.weapon.range || 80;
                    const angle = player.rotation || 0;
                    
                    gameCtx.save();
                    gameCtx.globalAlpha = 0.15;
                    
                    // Рисуем сектор атаки (90 градусов)
                    gameCtx.beginPath();
                    gameCtx.moveTo(player.x - camX, player.y - camY);
                    const sectorAngle = angle - Math.PI / 2;
                    gameCtx.arc(player.x - camX, player.y - camY, range, sectorAngle - Math.PI/4, sectorAngle + Math.PI/4);
                    gameCtx.closePath();
                    gameCtx.fillStyle = '#1a1a1a';
                    gameCtx.fill();
                    
                    gameCtx.restore();
                }
            });
            // Препятствия
            obstacles.forEach(obstacle => {
                gameCtx.fillStyle = obstacle.type === 'wall' ? '#666' : 
                                   obstacle.type === 'block' ? '#444' : '#2a5a2a';
                gameCtx.fillRect(
                    obstacle.x - camX,
                    obstacle.y - camY,
                    obstacle.width,
                    obstacle.height
                );
            });
            // Оружие на карте
            weapons.forEach(weapon => {
                gameCtx.save();
                // Эффект пульсации для оружия
                const pulse = 0.7 + 0.3 * Math.sin(Date.now() / 200);
                gameCtx.globalAlpha = pulse;
                // Рисуем по типу
                if (weapon.type === 'knife') {
                    gameCtx.fillStyle = '#aaa';
                    gameCtx.fillRect(weapon.x - 10 - camX, weapon.y - 1 - camY, 20, 2);
                    gameCtx.fillStyle = '#888';
                    gameCtx.fillRect(weapon.x + 10 - camX, weapon.y - 2 - camY, 4, 4);
                } else if (weapon.type === 'greatsword') {
                    gameCtx.fillStyle = '#444';
                    gameCtx.fillRect(weapon.x - 22 - camX, weapon.y - 3 - camY, 44, 6);
                    gameCtx.fillStyle = '#b97a56';
                    gameCtx.fillRect(weapon.x + 18 - camX, weapon.y - 5 - camY, 10, 10);
                } else { // меч
                    gameCtx.fillStyle = '#8B4513';
                    gameCtx.fillRect(weapon.x - 15 - camX, weapon.y - 2 - camY, 30, 4);
                    gameCtx.fillStyle = '#654321';
                    gameCtx.fillRect(weapon.x + 15 - camX, weapon.y - 3 - camY, 8, 6);
                }
                // Текст названия
                gameCtx.globalAlpha = 1.0;
                gameCtx.fillStyle = '#FFD700';
                gameCtx.font = '12px Arial';
                gameCtx.textAlign = 'center';
                gameCtx.fillText(weapon.name, weapon.x - camX, weapon.y - 15 - camY);
                gameCtx.restore();
            });
            
            // Игроки
            players.forEach(player => {
                const isCurrentPlayer = player.id === currentPlayerId;
                const px = player.x - camX;
                const py = player.y - camY;
                
                gameCtx.save();
                gameCtx.translate(px, py);
                gameCtx.rotate(player.rotation || 0);
                // Тень под игроком
                gameCtx.save();
                gameCtx.globalAlpha = 0.25;
                gameCtx.fillStyle = '#000';
                gameCtx.beginPath();
                gameCtx.ellipse(0, 8, 12, 5, 0, 0, 2 * Math.PI);
                gameCtx.fill();
                gameCtx.restore();
                // Свечение вокруг текущего игрока (не показываем для умерших)
                if (isCurrentPlayer && !player.isDead) {
                    gameCtx.save();
                    gameCtx.shadowColor = '#00f0ff';
                    gameCtx.shadowBlur = 18;
                    gameCtx.beginPath();
                    gameCtx.arc(0, 0, 13, 0, 2 * Math.PI);
                    gameCtx.strokeStyle = '#00f0ff';
                    gameCtx.lineWidth = 2;
                    gameCtx.stroke();
                    gameCtx.restore();
                }
                // Тело
                gameCtx.beginPath();
                gameCtx.arc(0, 0, 10, 0, 2 * Math.PI);
                // Цвет игрока (серый если мертв)
                if (player.isDead) {
                    gameCtx.fillStyle = '#666666';
                    gameCtx.globalAlpha = 0.7;
                } else {
                    gameCtx.fillStyle = player.color;
                }
                gameCtx.fill();
                // Бордер
                if (player.isDead) {
                    gameCtx.strokeStyle = '#666666';
                    gameCtx.lineWidth = 1;
                } else {
                    gameCtx.strokeStyle = isCurrentPlayer ? '#ffffff' : '#333';
                    gameCtx.lineWidth = isCurrentPlayer ? 3 : 1;
                }
                gameCtx.stroke();
                // Глаза
                if (player.isDead) {
                    gameCtx.fillStyle = '#333333';
                } else {
                    gameCtx.fillStyle = '#ffffff';
                }
                gameCtx.beginPath();
                gameCtx.arc(-4, -3, 2, 0, 2 * Math.PI);
                gameCtx.fill();
                gameCtx.beginPath();
                gameCtx.arc(4, -3, 2, 0, 2 * Math.PI);
                gameCtx.fill();
                
                // Оружие в руках (не показываем для умерших)
                if (player.weapon && !player.isDead) {
                    gameCtx.save();
                    gameCtx.translate(0, -12);
                    let w = player.weapon;
                    let weaponRotation = 0;
                    if (isCurrentPlayer && attackAnimation.isActive && !player.isDead) {
                        const elapsed = Date.now() - attackAnimation.startTime;
                        const progress = elapsed / attackAnimation.duration;
                        weaponRotation = Math.sin(progress * Math.PI) * 0.5 * attackAnimation.swingDirection;
                    } else if (playerAttackAnimations.has(player.id) && !player.isDead) {
                        const animation = playerAttackAnimations.get(player.id);
                        const elapsed = Date.now() - animation.startTime;
                        const progress = elapsed / animation.duration;
                        weaponRotation = Math.sin(progress * Math.PI) * 0.5 * animation.swingDirection;
                    }
                    if (isCurrentPlayer && attackAnimation.isActive && !player.isDead) {
                        gameCtx.shadowColor = '#FF4500';
                        gameCtx.shadowBlur = 15;
                    }
                    gameCtx.rotate(weaponRotation);
                    // Рисуем по типу
                    if (w.type === 'knife') {
                        gameCtx.fillStyle = '#aaa';
                        gameCtx.fillRect(-10, -1, 20, 2);
                        gameCtx.fillStyle = '#888';
                        gameCtx.fillRect(10, -2, 4, 4);
                    } else if (w.type === 'greatsword') {
                        gameCtx.fillStyle = '#444';
                        gameCtx.fillRect(-22, -3, 44, 6);
                        gameCtx.fillStyle = '#b97a56';
                        gameCtx.fillRect(18, -5, 10, 10);
                    } else { // меч
                        gameCtx.fillStyle = '#8B4513';
                        gameCtx.fillRect(-15, -2, 30, 4);
                        gameCtx.fillStyle = '#654321';
                        gameCtx.fillRect(15, -3, 8, 6);
                    }
                    gameCtx.shadowBlur = 0;
                    gameCtx.restore();
                }
                
                gameCtx.restore();
                
                // Полоска здоровья
                const healthBarWidth = 30;
                const healthBarHeight = 4;
                const healthBarY = py - 35;
                
                // Фон полоски здоровья
                gameCtx.fillStyle = '#333333';
                gameCtx.fillRect(px - healthBarWidth/2, healthBarY, healthBarWidth, healthBarHeight);
                
                // Заполнение полоски здоровья
                const healthPercentage = (player.health || 10) / (player.maxHealth || 10);
                const healthFillWidth = healthBarWidth * healthPercentage;
                
                // Для умерших игроков не показываем заполнение хпбара
                if (!player.isDead) {
                    gameCtx.fillStyle = healthPercentage > 0.5 ? '#00ff00' : healthPercentage > 0.25 ? '#ffff00' : '#ff0000';
                    gameCtx.fillRect(px - healthBarWidth/2, healthBarY, healthFillWidth, healthBarHeight);
                }
                
                // Граница полоски здоровья
                if (player.isDead) {
                    gameCtx.strokeStyle = '#666666';
                } else {
                    gameCtx.strokeStyle = '#ffffff';
                }
                gameCtx.lineWidth = 1;
                gameCtx.strokeRect(px - healthBarWidth/2, healthBarY, healthBarWidth, healthBarHeight);
                
                // Текст здоровья
                gameCtx.fillStyle = '#ffffff';
                gameCtx.font = '10px Arial';
                gameCtx.textAlign = 'center';
                if (player.isDead) {
                    gameCtx.fillStyle = '#ff4444';
                    gameCtx.fillText('МЕРТВ', px, healthBarY - 5);
                } else {
                    gameCtx.fillText(`${player.health || 10}/${player.maxHealth || 10}`, px, healthBarY - 5);
                }
                // Fade для имени (имя появляется плавно, если игрок на экране)
                let nameAlpha = 1.0;
                if (px < 0 || px > canvasWidth || py < 0 || py > canvasHeight) nameAlpha = 0;
                else if (px < 40 || px > canvasWidth - 40 || py < 30 || py > canvasHeight - 30) nameAlpha = 0.3;
                gameCtx.save();
                gameCtx.globalAlpha = nameAlpha;
                if (player.isDead) {
                    gameCtx.fillStyle = '#666666';
                    gameCtx.globalAlpha = nameAlpha * 0.7;
                } else {
                    gameCtx.fillStyle = '#ffffff';
                }
                gameCtx.font = '12px Arial';
                gameCtx.textAlign = 'center';
                gameCtx.fillText(player.name, px, py - 20);
                gameCtx.globalAlpha = 1.0;
                gameCtx.restore();
                
                // Полоска кд (cooldown bar)
                if (isCurrentPlayer && player.weapon && nextAttackTime > Date.now() && !player.isDead) {
                    const cdBarWidth = 30;
                    const cdBarHeight = 4;
                    const cdBarY = py - 28;
                    const weaponCooldown = player.weapon.cooldown || getWeaponCooldown(player.weapon.type);
                    const cdLeft = Math.max(0, nextAttackTime - Date.now());
                    const cdPercent = 1 - cdLeft / weaponCooldown;
                    // Фон
                    gameCtx.fillStyle = '#222';
                    gameCtx.fillRect(px - cdBarWidth/2, cdBarY, cdBarWidth, cdBarHeight);
                    // Заполнение
                    gameCtx.fillStyle = '#00bfff';
                    gameCtx.fillRect(px - cdBarWidth/2, cdBarY, cdBarWidth * cdPercent, cdBarHeight);
                    // Граница
                    gameCtx.strokeStyle = '#fff';
                    gameCtx.lineWidth = 1;
                    gameCtx.strokeRect(px - cdBarWidth/2, cdBarY, cdBarWidth, cdBarHeight);
                }
            });
            // Рендерим частицы
            renderParticles();
            
            // Миникарта
            renderMinimap();
            renderInventory();
            renderDashCooldown();
            renderPlayerSpeed();
            requestAnimationFrame(renderGame);
        }
        
        function renderMinimap() {
            minimapCtx.fillStyle = '#0a0a0a';
            minimapCtx.fillRect(0, 0, 200, 150);
            
            const scaleX = 200 / mapWidth;
            const scaleY = 150 / mapHeight;
            
            // Draw obstacles on minimap
            obstacles.forEach(obstacle => {
                minimapCtx.fillStyle = '#666';
                minimapCtx.fillRect(
                    obstacle.x * scaleX,
                    obstacle.y * scaleY,
                    obstacle.width * scaleX,
                    obstacle.height * scaleY
                );
            });
            
            // Draw weapons on minimap
            weapons.forEach(weapon => {
                minimapCtx.fillStyle = '#FFD700';
                minimapCtx.beginPath();
                minimapCtx.arc(
                    weapon.x * scaleX,
                    weapon.y * scaleY,
                    1.5,
                    0,
                    2 * Math.PI
                );
                minimapCtx.fill();
            });
            
            // Draw players on minimap
            players.forEach(player => {
                if (player.isDead) {
                    minimapCtx.fillStyle = '#666666';
                    minimapCtx.globalAlpha = 0.5;
                } else {
                    minimapCtx.fillStyle = player.id === currentPlayerId ? '#ffffff' : player.color;
                }
                minimapCtx.beginPath();
                minimapCtx.arc(
                    player.x * scaleX,
                    player.y * scaleY,
                    2,
                    0,
                    2 * Math.PI
                );
                minimapCtx.fill();
                minimapCtx.globalAlpha = 1.0;
            });
        }
        
        function createAttackParticles(x, y, rotation) {
            // Смещение меча в локальных координатах (как в translate)
            const localOffsetX = 0;
            const localOffsetY = -12;
            // Длина меча (от translate до кончика)
            const swordLength = 30;

            // Считаем глобальные координаты кончика меча
            const tipX = x + Math.cos(rotation) * localOffsetY - Math.sin(rotation) * localOffsetX + Math.cos(rotation) * swordLength;
            const tipY = y + Math.sin(rotation) * localOffsetY + Math.cos(rotation) * localOffsetX + Math.sin(rotation) * swordLength;

            const particleCount = 8;
            for (let i = 0; i < particleCount; i++) {
                const angle = rotation + (Math.random() - 0.5) * Math.PI / 6;
                const speed = 2 + Math.random() * 3;
                const life = 20 + Math.random() * 30;

                particles.push({
                    x: tipX,
                    y: tipY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: life,
                    maxLife: life,
                    color: `hsl(${Math.random() * 60 + 15}, 100%, 50%)`,
                    size: 2 + Math.random() * 3
                });
            }
        }
        
        function createDashEffect(x, y) {
            // Создаем эффект рывка - частицы в форме следа
            const particleCount = 15;
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                const life = 30 + Math.random() * 20;

                particles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: life,
                    maxLife: life,
                    color: `hsl(${200 + Math.random() * 40}, 100%, 70%)`,
                    size: 3 + Math.random() * 4
                });
            }
        }
        
        function updateParticles() {
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                particle.vx *= 0.95; // Замедление
                particle.vy *= 0.95;
                return particle.life > 0;
            });
        }
        
        function renderParticles() {
            particles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                gameCtx.save();
                gameCtx.globalAlpha = alpha;
                gameCtx.fillStyle = particle.color;
                gameCtx.beginPath();
                gameCtx.arc(
                    particle.x - camX,
                    particle.y - camY,
                    particle.size * alpha,
                    0,
                    2 * Math.PI
                );
                gameCtx.fill();
                gameCtx.restore();
            });
        }
        
        function updateLeaderboard(leaderboard) {
            const leaderboardList = document.getElementById('leaderboardList');
            if (leaderboard.length === 0) {
                leaderboardList.innerHTML = '<div style="color: #6b7280; font-size: 14px;">Нет игроков онлайн</div>';
                return;
            }
            
            leaderboardList.innerHTML = '';
            leaderboard.forEach(player => {
                const item = document.createElement('div');
                item.className = 'leaderboard-item';
                
                const rank = document.createElement('div');
                rank.className = 'leaderboard-rank';
                rank.textContent = player.rank;
                
                const color = document.createElement('div');
                color.className = 'leaderboard-player-color';
                color.style.backgroundColor = player.color;
                
                const name = document.createElement('div');
                name.className = 'leaderboard-name';
                name.textContent = player.name;
                
                const kills = document.createElement('div');
                kills.className = 'leaderboard-kills';
                kills.textContent = `${player.kills} 💀`;
                
                item.appendChild(rank);
                item.appendChild(color);
                item.appendChild(name);
                item.appendChild(kills);
                leaderboardList.appendChild(item);
            });
        }
        
        function sendMessage() {
            const message = chatInput.value.trim();
            if (message && socket) {
                socket.emit('chatMessage', message);
                chatInput.value = '';
            }
        }
        
        function addChatMessage(sender, message) {
            const messageDiv = document.createElement('div');
            messageDiv.style.marginBottom = '5px';
            
            // Специальные стили для системных сообщений
            if (sender === 'System') {
                messageDiv.style.fontSize = '11px';
                messageDiv.style.color = '#666';
                messageDiv.style.fontStyle = 'italic';
                messageDiv.innerHTML = `${message}`;
            } else {
                messageDiv.innerHTML = `<strong>${sender}:</strong> ${message}`;
            }
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function renderInventory() {
            const canvasWidth = gameCanvas.width;
            const canvasHeight = gameCanvas.height;
            const currentPlayer = players.find(p => p.id === currentPlayerId);
            if (!currentPlayer) return;
            
            // Если игрок мертв, показываем сообщение о смерти
            if (currentPlayer.isDead) {
                const invX = canvasWidth - 80;
                const invY = canvasHeight - 80;
                gameCtx.save();
                gameCtx.globalAlpha = 0.7;
                gameCtx.fillStyle = '#222';
                gameCtx.fillRect(invX, invY, 64, 64);
                gameCtx.globalAlpha = 1.0;
                gameCtx.fillStyle = '#ff4444';
                gameCtx.font = 'bold 12px Arial';
                gameCtx.textAlign = 'center';
                gameCtx.fillText('МЕРТВ', invX + 32, invY + 32);
                gameCtx.restore();
                return;
            }
            // Координаты инвентаря (правый нижний угол)
            const invX = canvasWidth - 80;
            const invY = canvasHeight - 80;
            gameCtx.clearRect(invX, invY, 64, 64);
            gameCtx.save();
            // Фон инвентаря
            gameCtx.globalAlpha = 0.7;
            gameCtx.fillStyle = '#222';
            gameCtx.fillRect(invX, invY, 64, 64);
            gameCtx.globalAlpha = 1.0;

            if (currentPlayer.weapon) {
                // Рисуем оружие по типу
                gameCtx.save();
                gameCtx.translate(invX + 32, invY + 32);
                let w = currentPlayer.weapon;
                if (w.type === 'knife') {
                    gameCtx.rotate(-0.2);
                    gameCtx.fillStyle = '#aaa';
                    gameCtx.fillRect(-10, -1, 20, 2);
                    gameCtx.fillStyle = '#888';
                    gameCtx.fillRect(10, -2, 4, 4);
                } else if (w.type === 'greatsword') {
                    gameCtx.rotate(0.2);
                    gameCtx.fillStyle = '#444';
                    gameCtx.fillRect(-22, -3, 44, 6);
                    gameCtx.fillStyle = '#b97a56';
                    gameCtx.fillRect(18, -5, 10, 10);
                } else { // меч
                    gameCtx.rotate(0.2);
                    gameCtx.fillStyle = '#8B4513';
                    gameCtx.fillRect(-15, -2, 30, 4);
                    gameCtx.fillStyle = '#654321';
                    gameCtx.fillRect(15, -3, 8, 6);
                }
                gameCtx.restore();
                // Название и урон
                gameCtx.fillStyle = '#fff';
                gameCtx.font = 'bold 12px Arial';
                gameCtx.textAlign = 'center';
                gameCtx.fillText(w.name, invX + 32, invY + 16);
                // Урон
                gameCtx.fillStyle = '#fff';
                gameCtx.font = 'bold 12px Arial';
                gameCtx.fillText(`Урон: ${w.damage}`, invX + 32, invY + 30);
                // Вес
                gameCtx.fillStyle = '#ffaa00';
                gameCtx.font = 'bold 12px Arial';
                gameCtx.fillText(`Вес: ${w.weight}`, invX + 32, invY + 44);
                // Прочность
                gameCtx.fillStyle = '#fff';
                gameCtx.font = 'bold 14px Arial';
                gameCtx.fillText(`${w.durability}/${w.type === 'knife' ? 2 : w.type === 'greatsword' ? 5 : 3}`, invX + 32, invY + 60);
            } else {
                gameCtx.fillStyle = '#888';
                gameCtx.font = 'bold 16px Arial';
                gameCtx.textAlign = 'center';
                gameCtx.fillText('Пусто', invX + 32, invY + 40);
            }
            gameCtx.restore();
        }
        
        function renderPlayerSpeed() {
            const currentPlayer = players.find(p => p.id === currentPlayerId);
            if (!currentPlayer || currentPlayer.isDead) return;
            
            // Координаты скорости (левый верхний угол, под КД рывка)
            const speedX = 20;
            const speedY = 80;
            const width = 120;
            const height = 30;
            
            gameCtx.save();
            
            // Фон
            gameCtx.globalAlpha = 0.8;
            gameCtx.fillStyle = '#222';
            gameCtx.fillRect(speedX, speedY, width, height);
            gameCtx.globalAlpha = 1.0;
            
            // Рамка
            gameCtx.strokeStyle = '#00ff00';
            gameCtx.lineWidth = 1;
            gameCtx.strokeRect(speedX, speedY, width, height);
            
            // Текст скорости
            gameCtx.fillStyle = '#00ff00';
            gameCtx.font = 'bold 12px Arial';
            gameCtx.textAlign = 'left';
            gameCtx.fillText(`Скорость: ${moveSpeed.toFixed(1)}`, speedX + 5, speedY + 20);
            
            gameCtx.restore();
        }
        
        function renderDashCooldown() {
            const currentPlayer = players.find(p => p.id === currentPlayerId);
            if (!currentPlayer || currentPlayer.isDead) return;
            
            // Координаты КД рывка (левый верхний угол)
            const cooldownX = 20;
            const cooldownY = 20;
            const size = 50;
            
            gameCtx.save();
            
            // Фон
            gameCtx.globalAlpha = 0.8;
            gameCtx.fillStyle = '#222';
            gameCtx.fillRect(cooldownX, cooldownY, size, size);
            gameCtx.globalAlpha = 1.0;
            
            // Рамка
            if (isDashing) {
                gameCtx.strokeStyle = '#ffff00';
            } else {
                gameCtx.strokeStyle = dashCooldown ? '#666' : '#00bfff';
            }
            gameCtx.lineWidth = 2;
            gameCtx.strokeRect(cooldownX, cooldownY, size, size);
            
            // Иконка рывка
            if (isDashing) {
                gameCtx.fillStyle = '#ffff00';
                gameCtx.font = 'bold 20px Arial';
                gameCtx.textAlign = 'center';
                gameCtx.fillText('⚡', cooldownX + size/2, cooldownY + size/2 + 5);
            } else {
                gameCtx.fillStyle = dashCooldown ? '#666' : '#00bfff';
                gameCtx.font = 'bold 20px Arial';
                gameCtx.textAlign = 'center';
                gameCtx.fillText('⚡', cooldownX + size/2, cooldownY + size/2 + 5);
            }
            
            // Прогресс КД
            if (dashCooldown && !isDashing) {
                const elapsed = Date.now() - dashStartTime;
                const progress = Math.min(elapsed / dashCooldownTime, 1);
                
                gameCtx.fillStyle = '#00bfff';
                gameCtx.globalAlpha = 0.3;
                gameCtx.fillRect(cooldownX, cooldownY + size * (1 - progress), size, size * progress);
                gameCtx.globalAlpha = 1.0;
                
                // Время до готовности
                const remaining = Math.ceil((dashCooldownTime - elapsed) / 1000);
                gameCtx.fillStyle = '#fff';
                gameCtx.font = 'bold 12px Arial';
                gameCtx.fillText(`${remaining}s`, cooldownX + size/2, cooldownY + size + 15);
            }
            
            gameCtx.restore();
        }
        
        // Allow Enter key to join game
        nicknameInput.addEventListener('keypress', (e) => {
            if (e.code === 'Enter') {
                joinGame();
            }
        });
        
        // Делаем функции доступными глобально
        window.respawnPlayer = respawnPlayer;
        window.showRespawnModal = showRespawnModal;
        window.hideRespawnModal = hideRespawnModal;
        
        // После показа gameContainer, тоже resize
        gameContainer.style.display = '';

        function openRulesModal() {
          document.getElementById('rulesModal').style.display = 'flex';
        }
        function closeRulesModal(e) {
          // Закрывать только если клик по фону или по ✕
          if (!e || e.target.classList.contains('rules-modal-backdrop') || e.target.classList.contains('rules-modal-close')) {
            document.getElementById('rulesModal').style.display = 'none';
          }
        }
    </script>
</body>
</html> 